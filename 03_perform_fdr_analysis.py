#!/usr/bin/env python

"""
This script uses a simple procedure to estimate the FDR of directed interactions for increasing P-value thresholds.

Initially, a Diachromatic interaction file is ingested and a binomial P-value is calculated for each interaction and
stored in a list. Furthermore, the total numbers of interactions for given read pair numbers n (n is the sum of simple
and twisted read pairs) are stored in dictionary with n as keys and interaction numbers as values.

This dictionary is then used to generate a list of random P-values for all interactions. A random P-value for an
interaction with n read pairs is generated by drawing a number of simple read pairs s' from a binomial distribution
B(n, p = 0.5), setting the number of twisted read pairs to t' to n - s' and calculating the corresponding binomial
P-value.

Finally, the FDR is estimated for increasing P-value thresholds. For each threshold, the number of significant
interactions is determined for the list of original P-values (S_o) and for the lists of randomized P-values (S_p) and
S_p / S_o is used as estimator for the FDR.
"""


import argparse
import gzip
from scipy.stats import binom
from collections import defaultdict
import numpy as np


### Parse command line
######################

parser = argparse.ArgumentParser(description='Determine a P-value threshold that corresponds to a given FDR threshold.')
parser.add_argument('--out-prefix', help='Prefix for output.', default='OUTPREFIX')
parser.add_argument('--interaction-file', help='Diachromatic interaction file.')
parser.add_argument('--fdr-threshold', help='Use this switch to estimate a P-value cutoff that corresponds to a given FDR threshold.', default=0.25)
parser.add_argument('--p-val-c-min', help='Smallest P-value cutoff.', default=0.00025)
parser.add_argument('--p-val-c-max', help='Largest P-value cutoff.', default=0.05)
parser.add_argument('--p-val-step-size', help='P-value step size.', default=0.00025)

args = parser.parse_args()
out_prefix = args.out_prefix
diachromatic_interaction_file = args.interaction_file
fdr_threshold = float(args.fdr_threshold)
p_val_c_min = float(args.p_val_c_min)
p_val_c_max = float(args.p_val_c_max)
p_val_step_size = float(args.p_val_step_size)

print("[INFO] " + "Input parameters")
print("\t[INFO] --out_prefix: " + out_prefix)
print("\t[INFO] --interaction-file: " + diachromatic_interaction_file)
print("\t[INFO] --fdr-threshold: " + str(fdr_threshold))
print("\t[INFO] --p-val-c-min: " + str(p_val_c_min))
print("\t[INFO] --p-val-c-max: " + str(p_val_c_max))
print("\t[INFO] --p-val-step-size: " + str(p_val_step_size))


### Define auxiliary functions
##############################

# Dictionary that keeps track of already calculated P-values
#    key - a string like 2-7
#    value - our corresponding binomial p-value
#    note -- use this as a global variable in this script!
pval_memo = defaultdict(float)

def binomial_p_value(simple_count, twisted_count):
    """
    Locally defined method for the calculation of the binomial P-value that uses a dictionary that keeps track of
    P-values that already have been calculated.

    :param simple_count: Number of simple read pairs
    :param twisted_count: Number of twisted read pairs
    :return: Binomial P-value
    """

    # Create key from simple and twisted read pair counts
    key = "{}-{}".format(simple_count, twisted_count)

    # Check whether a P-value for this combination of simple and twisted counts has been calculated already
    if key in pval_memo:
        return pval_memo[key]
    else:

        # Calculate P-value and add to dictionary
        if simple_count < twisted_count:
            p_value = 1 - binom.cdf(twisted_count - 1, simple_count + twisted_count, 0.5)
            pval_memo[key] = p_value
            return p_value
        else:
            p_value = 1 - binom.cdf(simple_count - 1, simple_count + twisted_count, 0.5)
            pval_memo[key] = p_value
            return p_value


def get_pvals_permuted_counts():
    """
    This function generates and returns a list of randomized binomial P-values.

    :return: List of randomized P-values
    """

    # Init list of randomized P-values
    pvals_permuted_counts = []

    # Iterate dictionary with numbers of interactions foreach read pair number n
    for n, i_num in N_DICT.items():

        # Generate random simple read pair counts for current n
        simple_count_list = list(binom.rvs(n, p = 0.5, size = i_num))

        for simple_count in simple_count_list:

            # Get twisted count
            twisted_count = n - simple_count

            # Get binomial P-value
            key = "{}-{}".format(simple_count, twisted_count)
            if key in pval_memo:
                pv = pval_memo[key]
            else:
                pv = binomial_p_value(simple_count, twisted_count)
                pval_memo[key] = pv

            pvals_permuted_counts.append(pv)

    return pvals_permuted_counts


### Prepare variables, data structures and streams for output files
###################################################################

# Dictionary that stores the numbers of interactions with n read pairs
N_DICT = {}

# Total number of input interactions
n_interaction = 0

# List of P-values for observed interactions
p_val_o_list = []

# Prepare stream for output of results
file_name = out_prefix + "_fdr_analysis_results.txt"
f_output = open(file_name, 'wt')
f_output.write("OUT_PREFIX\tFDR\tPC\tNSIG_P\tNSIG_O" + "\n")


### Start execution
###################

print("[INFO] Iterating Diachromatic interaction file ...")
with gzip.open(diachromatic_interaction_file, 'r' + 't') as fp:

    for line in fp:

        # Count total number of interactions
        n_interaction += 1

        # Report progress
        if n_interaction % 1000000 == 0:
            print("\t\t[INFO]", n_interaction, "interactions processed ...")

        # Split Diachromatic interaction line
        fields = line.rstrip('\n').split('\t')

        if len(fields) < 9:
            raise TypeError("Malformed diachromatic input line {} (number of fields {})".format(line, len(fields)))

        # Extract simple and twisted read pair counts from Diachromatic interaction line
        n_simple, n_twisted = fields[8].split(':')
        n_simple = int(n_simple)
        n_twisted = int(n_twisted)
        n = n_simple + n_twisted

        # Calculate P-value and add to list
        key = "{}-{}".format(n_simple, n_twisted)
        if key in pval_memo:
            pv = pval_memo[key]
        else:
            pv = binomial_p_value(n_simple, n_twisted)
            pval_memo[key] = pv

        p_val_o_list.append(pv)

        # Add the sum of simple and twisted read pair counts to dictionary that will be used for randomization
        if n in N_DICT:
            N_DICT[n] +=1
        else:
            N_DICT[n] = 1

print("[INFO] Total number of interactions: {}".format(n_interaction))


print("[INFO] Estimating FDR for increasing P-value thresholds ...")

# Get list of randomized P-values
p_val_p_list = get_pvals_permuted_counts()

# Estimate FDR for increasing P-value thresholds from original and randomized P-value lists
for pc in np.arange(p_val_c_min, p_val_c_max, p_val_step_size):

    # Get number of significant interactions for original P-values
    nsig_o = (p_val_o_list < pc).sum()

    # Get number of significant interactions for randomized P-values
    nsig_p = (p_val_p_list < pc).sum()

    # Estimate FDR
    fdr = nsig_p / nsig_o

    # Write results for this threshold to file
    f_output.write(out_prefix + "\t" + str(fdr) + "\t" + str(pc) + "\t" + str(nsig_p) + "\t" + str(nsig_o) + "\n")

    # Print results for this threshold to file
    print("\t" + out_prefix + "\t" + str(fdr) + "\t" + str(pc) + "\t" + str(nsig_p) + "\t" + str(nsig_o))

    # Keep track of the largest P-value that satisfies the FDR threshold
    if fdr < fdr_threshold:
        fdr_last = fdr
        nsig_o_last = nsig_o
        nsig_p_last = nsig_p
        pc_last = pc

f_output.close()

# Print results for the largest P-value that satisfies the FDR threshold to the screen
print()
print("\tOUT_PREFIX\tFDR\tPC\tNSIG_P\tNSIG_O")
print("\t" + out_prefix + "\t" + str(fdr_last) + "\t" + str(pc_last) + "\t" + str(nsig_p_last) + "\t" + str(nsig_o_last))

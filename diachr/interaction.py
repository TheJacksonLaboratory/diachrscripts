from scipy.stats import binom
from .enhanced_interaction import EnhancedInteraction
from .digest import Digest


class Interaction:

    # Class to represent a genomic interaction between two restriction digests

    # Attributes

    #digest_distance = None  # Distance between the two interacting digests
    #n_simple = 0            # Number of simple read pairs
    #n_twisted = 0           # Number of twisted read pairs
    #cis = None              # Intra-chromosomal interaction
    #type = None             # Either simple, twisted or undirected
    #digest_1 = None
    #digest_2 = None
    #p_value = None
    #digest_pair_flag_original_order = None

    def __init__(self, ei: EnhancedInteraction):
        """
        Initialize an Interaction object from an EnhancedInteraction object
        Todo, consider whether we really need two different classes.
        """

        #fields = diachromatic_interaction_line.split("\t")
        self.digest_1 = Digest(ei.chr_a, ei.sta_a, ei.end_a)
        if ei.digest_a_enriched():
            self.digest_1.set_active()
        self.digest_2 = Digest(ei.chr_b, ei.sta_b, ei.end_b)
        if ei.digest_b_enriched():
            self.digest_2.set_active()

        #if ':' in fields[8]:  # line regular Diachromatic file
         #   fields2 = fields[8].split(":")
        self.n_simple = ei.simple_count
        self.n_twisted = ei.twisted_count
        #self.type = "TBD"  # to be determined using binomial P-value
        #else: # line from LRT script
        #    self.n_simple = fields[8]
        #    self.n_twisted = fields[9]
        #    self.type = fields[13].rstrip() # has been determined already using LRT
        #self.set_interaction_type(i_type)

        if self.digest_1.get_chromosome() == self.digest_2.get_chromosome():
            self.cis = True
        else:
            self.cis = False

        self.digest_pair_flag_original_order = ei.enrichment_pair_tag  # fields[3] + fields[7]

    # Methods

    def get_digest_pair_flag_original_order(self):
        return self.digest_pair_flag_original_order

    def get_digest_distance(self):
        if not self.is_cis():
            raise Exception("[FATAL] Digest distance is not defined for trans interactions.")
        if self.digest_distance == None:
            self.digest_distance = self.digest_2.get_start() - self.digest_1.get_end()
        return self.digest_distance

    def is_cis(self):
        return self.cis

    def get_digest_status_pair_flag(self):
        if self.digest_1.is_active():
            state_1 = 'A'
        else:
            state_1 = 'I'
        if self.digest_2.is_active():
            state_2 = 'A'
        else:
            state_2 = 'I'
        category = state_1 + state_2
        return sorted(category)[0]+sorted(category)[1]

    def get_binomial_p_value(self):
        if self.p_value != None:
            return self.p_value
        else:
            if self.n_simple < self.n_twisted:
                self.p_value = 1 - binom.cdf(self.n_twisted-1, self.n_simple + self.n_twisted, 0.5)
                return self.p_value
            else:
                self.p_value = 1 - binom.cdf(self.n_simple-1, self.n_simple + self.n_twisted, 0.5)
                return self.p_value


    def set_interaction_type(self, type, p_thresh, n_indefinable_cutoff):
        """
        This function determines whether this interaction is significantly directed, i.e. simple or twisted, using a
        binomial distribution with p = 0.5 and returns a 'S' for simple and 'T' for twisted.
        Otherwise, the function returns an 'U' for undirected or a 'NA', if the sum of twisted and simple is smaller
        than five because interactions with less read pairs cannot be significant using the binomial distribution.
        If the interaction input file was generated by the LRT script, the type of this interaction is set to the
        given type. Note that interactions from LRT cannot have the type 'NA'.

        :return: 'S' (simple),'T' (twisted), 'U' (undirected), 'NA' (not available)
        """
        if(type != 'S' and type != 'T' and type != 'U' and type != "TBD"):
            raise Exception("[FATAL] Invalid interaction type. Should be either 'S', 'T', 'U' or 'TBD' but was " + type + ".")
        else:
            if type == "TBD":
                if self.n_twisted + self.n_simple < n_indefinable_cutoff:
                    type = 'NA' # an interaction with less than 5 read pairs cannot be significant with a binomial P-value threshold of 0.05
                elif self.get_binomial_p_value() <= p_thresh:
                    if self.n_twisted < self.n_simple:
                        type = 'S'
                    else:
                        type = 'T'
                else:
                    type = 'U'
            self.type = type

    def get_interaction_type(self):
        return self.type

    def get_first_digest(self):
        return self.digest_1

    def get_second_digest(self):
        return self.digest_2

    def is_cis_long_range(self, d_dist):
        if not self.is_cis():
            return False
        if self.get_digest_distance() < d_dist:
            return False
        return True

    def get_coord_string(self):
        """
        returns a string such as chr1:123-456;chr1:1000-2000
        """
        return self.digest_1.coordinate_string + ";" + self.digest_2.coordinate_string
